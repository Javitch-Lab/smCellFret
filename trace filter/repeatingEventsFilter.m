function [ valFilter ] = ...
    repeatingEventsFilter(segments,N,centroidDist,offTimeLim)      
%--------------------------------------------------------------------------
% 
% repeatingEventsFilter.m:
%   Subfunction of scriptFretFilter.m
% 
% Description:
%   The function evaluates whether trace_i is part of a series of events
%   that recur at the same location and follow each other in time.
%
% Syntax:  
%   [ valFilter ] = ...
%   repeatingEventsFilter(segments,N,centroidDist,offTimeLim)      
% 
% Inputs:
%   1. segments     - Cell array with all tracks crossing the neighborhood 
%                     region R of track i. This input array is generated by 
%                     the subfunction getSegments.m. 
%   2. N            - Integer Number that specifies the maximum number of 
%                     tracks that are allowed to overlap spatially and 
%                     temporally with track_i (e.g N = 25) 
%   3. centroidDist - Distance limit between a track_i and a track_j. Below 
%                     this centroid distance, the two tracks are considered 
%                     as overlapping tracks (e.g. centroidDist=1.5 pixels) 
%   4. offTimeLim   - Upper mean lifetime limit of the n spatio-temporal 
%                     overlapping tracks (e.g. offTimeLim = 0.4s)
% 
% Outputs:
%   valFilter       - Logical variable that can be either TRUE (accept  
%                     trace) or FALSE (discard trace).
% Example: 
%   If trace_i
%       1. spatially overlaps with more than N segments 
%          (space matching criterion) 
%   AND
%       2. is temporally overlapping with these segments  
%          (time matching criterion)
%          todo: specify the time gap between recurring traces 
%   AND
%       3. the mean lifetime of all spatially and temporally matching   
%          traces is short, i.e. mean lifetime < offTimeLim (lifetime 
%          criterion). 
%   THAN 
%       4. The filter returns logically FALSE (trace_i is discarded because 
%          it is part of a series with spatially recurring events). 
%
%  OTHERWISE 
%       5. The filter returns logical TRUE (trace_i is accepted)
% 
% See also: 
%   getSegments.m, scriptFretFilter.m
%
% Authors: 
%   - P.G. Nov 2017
%
% Copyright:
%    2011-2020 Columbia Univiversity / RFMH All Rights Reserved.
%
% -------------------------------------------------------------------------



% Initialize variables
valFilter    = struct('idxFlt',[],'lenSequence',[],'idsOfSeq',[],'offTime',[]);   
nSgm        = size(segments,1);
idsOfSeq    = NaN;
meanOffTime = inf;

% If segments exist chk whether it is a sequence of events
if nSgm >= 2
    
    % Space Matching Criterion
    dst = zeros(nSgm,1);
    
    % Check centroid distance between trace_i and segments 1...j
    xCentPts = segments{1,4}(1);
    yCentPts = segments{1,4}(2);   
    for j=1:nSgm    
        dst(j) = ((segments{j,4}(1)- xCentPts).^2 + ...
                 (segments{j,4}(2) - yCentPts).^2)^0.5;
    end
    
    % Generate Vector sameLocation
    sameLocation = dst < centroidDist;

    % Select sgm with sameLocation=true and check how many segments of 
    % these are in sequence
    times       = [segments{sameLocation,2};... % SOT
                   segments{sameLocation,3};... % EOT
                   segments{sameLocation,1}]';  % trace number
    sortedTimes = sortrows(times, 1, {'ascend'});
    firstTime   = sortedTimes(1,1);
    lastTime    = sortedTimes(end,1);
    lenIds      = size(sortedTimes,1);
    offTime     = inf;
    if firstTime ~= lastTime
        j=1; 
        while j < lenIds
            th   = sortedTimes(j,1);
            ti   = sortedTimes(j,2);
            tj   = sortedTimes(j+1,1);
            onTime   = tj - ti; % in s
            offTime  = ti - th; % in s
            sortedTimes(j+1,4) = onTime;
            sortedTimes(j,5)   = offTime;
            idx  = ti <= tj;
            if idx == 0
                sortedTimes(j+1,:)=[];
                lenIds = size(sortedTimes,1);
                if lenIds < j+1, break; end
            else
                j=j+1;
                lenIds = size(sortedTimes,1);
                if lenIds <j+1, break; end
            end
        end
    end

    idsOfSeq    = sortedTimes(:,3)';
    lenSequence = size(sortedTimes,1);

    % Estimate the lifetimes and if the sequence has more then N segments
    if offTime < inf   
        meanOffTime = expfit(sortedTimes(1:end-1,5));
    end

elseif nSgm == 1
    idsOfSeq    = segments{1,1}; 
    lenSequence = 1;
    meanOffTime = segments{1,3}-segments{1,2};
    sortedTimes = [];
    dst         = [];
end

% Save Filter Results   
isRepeat              = lenSequence > N && meanOffTime <= offTimeLim;
% If trace_i belongs to a sequence of spatially and temporally matching 
% traces THAN reject the trace: Set Filter result to logical False or 0. 
valFilter.idxFlt      = ~isRepeat; 
valFilter.dist        = dst;
valFilter.sortedTimes = sortedTimes;
valFilter.lenSequence = lenSequence;
valFilter.idsOfSeq    = idsOfSeq;
valFilter.offTime     = meanOffTime;

