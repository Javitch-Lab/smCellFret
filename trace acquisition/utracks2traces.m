function trackIndex=utracks2traces(filename, dt, nFrames, roiData)
%--------------------------------------------------------------------------
%
% utracks2traces.m:
%   The function converts the 'compound tracks' format used in u-track to a 
%   fretTraces file format.
% 
% Syntax:  
%   trackIndex=utracks2traces(filename, dt, nFrames, roiData)
% 
% Inputs:
%   1. filename - A Tracking.mat file generated by u-track. 
%   2. dt       - Decimal number specifying the time resolution in seconds.
%   3. nFrames  - Integer number specifying the number of movie frames. 
%   4. roiData  - Optional (this variable is no longer used).
% 
% Outputs:
%   1. trackIdx - utracks2traces returns the variable trackIdx and also
%      saves it in the current working directory. The variable is a 
%      structure with the following fields: 
%      .ids         - trace id number
%      .seqOfEvents - The sequence of events matrix is generated in u-track 
%                     and describes merging and splitting events.
%      .nChannels   - number of merging and splitting events of a compund
%                     trace.
%   2. 'singleTracesCh1.traces' - File containing the fretTraces structure 
%       variable of the acceptor data. 
%   3. 'singleTracesCh2.traces' - File containing the fretTraces structure 
%       variable of the donor data. 
%   4. NOTE: The fretTraces structure for the donor and acceptor data has 
%      the following fields:
%       .nChannels         - The number of the primary fields being used. 
%       .channelNames      - Cell array containing the names of the primary 
%                            fields being used. 
%       .time              - Time in units of seconds. 
%       .x                 - x coordinate of the localized spot 
%       .y                 - y coordinate of the localized spot 
%       .int               - intensity value provided by u-track 
%       .traceMetadata.ids - trace identifiers.
%   5. NOTE: Both traces files 'singleTracesCh1.traces' and  
%      'singleTracesCh2.traces' will be renamed to 'singleTracesAcc.traces' 
%      and to 'singleTracesDon.traces' when running scriptGetFretTrace.m
% 
% See also: 
%   scriptGetFretTrace.m, u-track.m
%
% Authors: 
%   -P.G. Apr 2011
%   -P.G. Dec 2011
%   -P.G. Feb 2014 
%
% Copyright:
%    2011-2020 Columbia Univiversity / RFMH All Rights Reserved.
%
% -------------------------------------------------------------------------

%% ----
%  ---- Load Data
%  ---- 

% Load structure array 
if nargin > 0,
    sptData=load(filename, '-mat'); 
else
    sptData=load('Tracking.mat'); 
end

if nargin < 4; roiData=[]; end;
    
%Determine the number of singleTracks, doubleTracks and quadrupelTracks in the dataset
nTraces=size(sptData.tracksFinal,1);

% Determine existing track orders in sptData set: single, double, triple, quadrupel, ...
trackOrder=[];
for i=1:nTraces
    [nEvents,~]=size(sptData.tracksFinal(i,1).tracksCoordAmpCG); % ~ skip lenEvents 
    trackOrder=[trackOrder nEvents];
end

%% ----
%  ---- Analyze Track orders
%  ---- 
% Histogram of Events (distribution of track orders)
maxOrder=11;bin=1;
distTrackOrder=zeros(2,maxOrder);
distTrackOrder(2,:)=hist(trackOrder,1:bin:maxOrder);
distTrackOrder(1,:)=1:bin:maxOrder;
indTrackOrder=find(distTrackOrder(2,:));

if max(indTrackOrder) > 10
    indTrackOrder=indTrackOrder(1:numel(indTrackOrder)-1);
end

seqTrackOrders={'single'; 'double'; 'triple';'quadruple'; 'quintuple'; ...
    'sextuple'; 'septuple';'octuple'; 'nontuple'; 'dectuple'};

%Allocate memory for n-tupelTracks
for i=1:numel(indTrackOrder);
    order=indTrackOrder(i);
    fn=seqTrackOrders{order};
    trackIndex.(fn).ids         = zeros(distTrackOrder(2,order),1);
    trackIndex.(fn).seqOfEvents = zeros(2*order,4,distTrackOrder(2,order));
end

j=zeros(1,11);
for i=1:nTraces
    [nEvents,~]=size(sptData.tracksFinal(i,1).tracksCoordAmpCG);
    if     distTrackOrder(2,1) > 0 && nEvents == 1
        j(1)=j(1)+1;trackIndex.single.ids(j(1),1)             = i;
                    trackIndex.single.nChannels               = nEvents;
                    trackIndex.single.seqOfEvents(:,:,j(1))   = sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,2) > 0 && nEvents == 2
        j(2)=j(2)+1;trackIndex.double.ids(j(2),1)             = i;
                    trackIndex.double.nChannels               = nEvents;
                    trackIndex.double.seqOfEvents(:,:,j(2))   = sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,3) > 0 && nEvents == 3
        j(3)=j(3)+1;trackIndex.triple.ids(j(3),1)             = i;
                    trackIndex.triple.nChannels               = nEvents;
                    trackIndex.triple.seqOfEvents(:,:,j(3))   = sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,4) > 0 && nEvents == 4
        j(4)=j(4)+1;trackIndex.quadruple.ids(j(4),1)          = i;
                    trackIndex.quadruple.nChannels            = nEvents;
                    trackIndex.quadruple.seqOfEvents(:,:,j(4))= sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,5) > 0 && nEvents == 5
        j(5)=j(5)+1;trackIndex.quintuple.ids(j(5),1)          = i;
                    trackIndex.quintuple.nChannels            = nEvents;
                    trackIndex.quintuple.seqOfEvents(:,:,j(5))= sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,6) > 0 && nEvents == 6
        j(6)=j(6)+1;trackIndex.sextuple.ids(j(6),1)           = i;
                    trackIndex.sextuple.nChannels             = nEvents;
                    trackIndex.sextuple.seqOfEvents(:,:,j(6)) = sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,7) > 0 && nEvents == 7
        j(7)=j(7)+1;trackIndex.septuple.ids(j(7),1)           = i;
                    trackIndex.septuple.nChannels             = nEvents;
                    trackIndex.septuple.seqOfEvents(:,:,j(7)) = sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,8) > 0 && nEvents == 8
        j(8)=j(8)+1;trackIndex.octuple.ids(j(8),1)            = i;
                    trackIndex.octuple.nChannels              = nEvents;
                    trackIndex.octuple.seqOfEvents(:,:,j(8))  = sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,9) > 0 && nEvents == 9
        j(9)=j(9)+1;trackIndex.nontuple.ids(j(9),1)           = i;
                    trackIndex.nontuple.nChannels             = nEvents;
                    trackIndex.nontuple.seqOfEvents(:,:,j(9)) = sptData.tracksFinal(i,1).seqOfEvents;
    elseif distTrackOrder(2,10) > 0 && nEvents == 10
      j(10)=j(10)+1;trackIndex.dectuple.ids(j(10),1)          = i;
                    trackIndex.dectuple.nChannels             = nEvents;
                    trackIndex.dectuple.seqOfEvents(:,:,j(10))= sptData.tracksFinal(i,1).seqOfEvents;
    end
end

% Trace indices of single, double, triple, ... tracks
for g=1:numel(indTrackOrder)
    order=indTrackOrder(g);
    fn=seqTrackOrders{order};
    disp([fn 'Traces :' num2str(numel(trackIndex.(fn).ids))]);
end

% Time data
timeAxis=(1:nFrames)*dt;

%% ----
%  ---- converting uTracks to traces
%  ----

for h=1:numel(indTrackOrder)
    %Determine the track order and load tracks 
    order=indTrackOrder(h);
    n_tupel=seqTrackOrders{order};

    % Parameter initialization for an n-tupel trace
    nTracks    = numel(trackIndex.(n_tupel).ids(:,1));
    traceID    = trackIndex.(n_tupel).ids(:,1);
    nChannels  = trackIndex.(n_tupel).nChannels(1);

    % Create n-channel traces matrix (memory allocation)   
    n_tupelTraces=zeros((3*nTracks)+1,nFrames,nChannels);

    % Set time axis 
    for l=1:nChannels
        n_tupelTraces(1,:,l)=timeAxis;
    end
    % Convert tracks into traces files
    for i=1:nTracks
        % Initialize parameters and allocate memory
        j=traceID(i);
        indCh=zeros(nChannels,2);
        tracks=zeros(3,nFrames,nChannels);
        dimCh=zeros(nChannels,1);
        for k=1:nChannels
            indRow=find(sptData.tracksFinal(j,1).seqOfEvents(:,3)==k)';
            indCh(k,1)= sptData.tracksFinal(j,1).seqOfEvents(indRow(1,1),1);
            indCh(k,2)= sptData.tracksFinal(j,1).seqOfEvents(indRow(1,2),1);
            %Save x-Coordinate
            lenData=size(sptData.tracksFinal(j,1).tracksCoordAmpCG(k,1:8:end),2);
            tracks(1,1:lenData,k)=sptData.tracksFinal(j,1).tracksCoordAmpCG(k,1:8:end);
            %Save y-Coordinate
            tracks(2,1:lenData,k)=sptData.tracksFinal(j,1).tracksCoordAmpCG(k,2:8:end);
            %Save Intensity
            tracks(3,1:lenData,k)=sptData.tracksFinal(j,1).tracksCoordAmpCG(k,4:8:end);
            %Size of real sptData in tracks matrix
            dimCh(k)=abs(indCh(k,1)-indCh(k,2))+1;
            %Save tracks in traces format
            if k==1
                n_tupelTraces(3*i-1,indCh(k,1):indCh(k,2),k)= tracks(1,1:dimCh(k),k);
                n_tupelTraces(3*i,indCh(k,1):indCh(k,2),k)= tracks(2,1:dimCh(k),k);
                n_tupelTraces(3*i+1,indCh(k,1):indCh(k,2),k)= tracks(3,1:dimCh(k),k);
            elseif k>1
                dStart=indCh(k,1)-indCh(1,1)+1;
                n_tupelTraces(3*i-1,indCh(k,1):indCh(k,2),k)= tracks(1,dStart:dStart+dimCh(k)-1,k);
                n_tupelTraces(3*i,indCh(k,1):indCh(k,2),k)= tracks(2,dStart:dStart+dimCh(k)-1,k);
                n_tupelTraces(3*i+1,indCh(k,1):indCh(k,2),k)= tracks(3,dStart:dStart+dimCh(k)-1,k);
            end
        end    
    end
    % save n-tupelTraces
    traces.(n_tupel)=n_tupelTraces(:,:,:);
end


%% ----
%  ---- Save files
%  ----

% Get current filepath
path = fileparts(filename);

% Save compound traces files
for h=1:numel(indTrackOrder)
    order=indTrackOrder(h);
    n_tupel=seqTrackOrders{order};
    if distTrackOrder(2,order) > 0
        for m=1:order
            
            %determine number of traces
            idList=trackIndex.(n_tupel).ids(:,1);
            nTraces=numel(idList);
            
            %save data in tmporary variables
            x      = traces.(n_tupel)(2:3:end,:);
            y      = traces.(n_tupel)(3:3:end,:);
            int    = traces.(n_tupel)(4:3:end,:);
            idList = trackIndex.(n_tupel).ids(:,1);
            
            %only keep the subset of traces located in the ROI
            if ~isempty(roiData)
                tracesStart=zeros(nTraces,2);
                for k=1:nTraces; 
                    ind=find(x(k,:)>0,1,'first');
                    tracesStart(k,1)=x(k,ind);
                    tracesStart(k,2)=y(k,ind);
                end
                xCor=tracesStart(:,1);
                yCor=tracesStart(:,2);
                xRoi=roiData(:,1);
                yRoi=roiData(:,2);
                in=inpolygon(xCor, yCor, xRoi, yRoi);
                x       = x(in,:);
                y       = y(in,:);
                int     = int(in,:);
                nTraces = size(x,1);
                idList  = idList(1:nTraces);
                trackIndex.(n_tupel).ids = idList;
                disp(['singleTraces (ROI) :' num2str(nTraces)]);
            end
            
            %save data in a data structure
            data.time = traces.(n_tupel)(1,:);
            data.x    = x;
            data.y    = y;
            data.int  = int; 
            
            %create ids
            name=[char(n_tupel) 'TracesCh' num2str(m)];
            for j=1:nTraces
                data.traceMetadata(j).ids = sprintf('%s_%d', name, idList(j));
            end
            
            %save data
            outfile=[path '\' char(n_tupel) 'TracesCh' num2str(m) '.traces'];
            saveTracesCell(outfile,'traces',data);
        end
    end
end

% Save trackIndex structure
save([path '\trackIndex.mat'],'-mat','trackIndex');

end

