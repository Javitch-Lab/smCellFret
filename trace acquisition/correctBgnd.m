function correctBgnd( filename, baseline, outfileCorr, outfileBgd )
%--------------------------------------------------------------------------
%
% correctBgnd.m:
%    Brings the baseline of the donor and acceptor intensity time traces 
%    down to zero 
%
% Description:
%    The function subtracts a calculated constant mean background value 
%    from each trace. After background correction, the baseline of each 
%    trace is close to zero. 
% 
% Syntax:  
%   correctBgnd( filename, baseline, outfileCorr, outfileBgd )
% 
% Inputs:
%   1. filename    - A trace file with the extension '_pht.traces'.
%   2. baseline    - variable with 4 columns and N (N = number of 
%      traces) rows:
%       a) lenBackset (1st column: length of the backset).
%       b) startOfTrace (2nd column: start of the current track)  
%       c) endOfTrace (3rd column: end of current track)
%       d) lenBaseline (4th column: length of the baseline) 
%      The matrix 'baseline' is generated by the function makeBaseline.m
%   3. outfileCorr - user-defined text for the filename containing the 
%                    updated fretTraces structure with background-corrected 
%                    trace data.  
%   4. outfileBgd  - user-defined text for the filename containing the 
%                    calculated background values for each of the N traces.  
%  
% Outputs:
%   If no user-defined file names are specified, the function saves the 
%   following two files in the working directory:
%   1. 'singleTracesAcc_phc.traces' - File containing the fretTraces 
%       structure with background corrected trace intensities. After the 
%       background correction step, the fretTraces structure now has the
%       following main fields:
%       .nChannels    - The number of the primary fields being used. 
%       .channelNames - Cell array containing the names of the primary 
%                       fields
%       .time  -  Time in units of seconds. 
%       .x     -  x coordinate of the localized spot 
%       .y     -  y coordinate of the localized spot 
%       .xCorr -  x coordinate after applying the transformation function
%       .yCorr -  y coordinate after applying the transformation function
%       .int   -  Background corrected locInt (locInt field see below)  
%       .snr   -  The local signal-to-background ratio is calculated by 
%                 dividing the integrated local spot intensity by the local 
%                 background signal. The local background signal (locBgd) 
%                 is calculated by integrating the pixel intensities over  
%                 the adjacent area of the psf (see fct. nPhotons.m).
%       .locInt - Integrated local spot intensities (unit is photons / 
%                 frame). The integration was performed over an area of 5x5
%                 pixels covering the spot's point spread function (psf).
%       .locBgd - Integrated local background intensities (unit is photons 
%                 / frame). The integration was performed over a 
%                 rectangular region adjacent to the spot's point spread 
%                 function (psf).
%       .traceMetadata - see scriptGetFretTraces for a description.
%   2. 'singleTracesAcc_bgd.traces' - File containing the fretTraces
%       structure as in 1. However, the calculated background intensities 
%       are now saved in the 'fretTraces.int' field. These values have to 
%       be subtracted from the .locInt field to get the corrected 
%       intensities.
% 
% See also: 
%   makeBaseline.m,  scriptGetFretTraces.m
%
% Authors: 
%   -P.G. July 2011
%   -P.G. July 2014 
%    use a moving average Filter (movavgFilt) to determine the mean of each 
%    the trace
%   -P.G. September 2014
%    save additional baseline information in _phc.traces traceMetadata
%   -P.G. Feb. 2016
%    added the option to save corrected traces and background traces in
%    user defined filenames: optional input: "outfileCorr.traces"
%    "outfileBgd.traces"
%   -P.G. Jul/Aug 2017
%    changed background calculation using statistics 
%
% Copyright:
%    2011-2020 Columbia Univiversity / RFMH All Rights Reserved.
%
% -------------------------------------------------------------------------


%
%% for test purposes
%  clear;
%  filename = 'W:\Disk E\#BackupMicData\2016 Jan-Jun\160223_DeltaTest-sf-D2S-Diffusion_10ms-5ms\500nM Dy549 10ms\PD 70\paramOpt Cell8\#08Ch1\singleTracesCh2_pht.traces';
%  baseline = dlmread('baseline.txt');

%% Initialize parameters
% width = 49;   % width of the movavg filter   
% alpha = 0.02; % percentage used to calculate the start and endpoint of a 
%               % the mean. Important for movavg filtering
%               % (movavg filter produces steep edges at the trace start and 
%               % end depending on the width of the filter)  

%% Load data 
data              = loadTracesCell(filename);
[nTraces,nFrames] = size(data.x);
intensity         = data.int;

%% Create or get an output filename
if nargin<3
    [path,name] = fileparts(filename);
    outfile1 = [path filesep name '.traces'];
    outfile1 = strrep(outfile1,'t.traces','c.traces');
    % Create output filename for background matrix
    outfile2=strrep(outfile1,'_phc.traces','_bgd.traces');
elseif nargin<4
    [path,name] = fileparts(outfileCorr);
    outfile1 = [path filesep name '.traces'];
    outfile2 = [];
elseif nargin<5
    [path1,name1] = fileparts(outfileCorr);
    [path2,name2] = fileparts(outfileBgd);
    outfile1 = [path1 filesep name1 '.traces'];
    outfile2 = [path2 filesep name2 '.traces'];
end

%% Calculate mean background and subtract mean background for every trace
lenBackset   = baseline(:,1);
startOfTrace = baseline(:,2); 
endOfTrace   = baseline(:,3);
lenBaseline  = baseline(:,4);
corrInt=zeros(nTraces,nFrames);
corrBgd=zeros(nTraces,nFrames);

 %% Calculate mean background by using a moving average filter
% for k=1:nTraces
%     traceStart  = startOfTrace(k)-lenBackset(k);
%     traceEnd    = endOfTrace(k)+lenBaseline(k);
%     bgndStart   = endOfTrace(k)+1;
%     if lenBaseline(k)<10
%         corrBgd(k,traceStart:traceEnd) = 0;
%         continue;
%     end
%     % start calc mean from the 2nd point of the baseline
%     bgInt = intensity(k,bgndStart:traceEnd);
%     meanBgInt = mean(bgInt);
%     stdvBgInt = std(bgInt);
%     
%     bgdMean = movavgFilt(bgInt, width, 'Center');
%     dx1=ceil(alpha*lenBaseline(k));
%     dx2=lenBaseline(k)-dx1;
%     %figure;
%     %plot(bgInt,'b'); hold on;
%     %plot(bgdMean(dx1:dx2), 'r','LineWidth',2);
%     
%     bgdMean=min(bgdMean(dx1:dx2));
%     if bgdMean < meanBgInt-2*stdvBgInt || bgdMean > meanBgInt+2*stdvBgInt
%         bgdMean=meanBgInt;
%     end
%     % bgnd entries only at positions from traceStart to traceEnd otherwise 
%     % corrInt Matrix will have negative entries
%     corrBgd(k,traceStart:traceEnd) = bgdMean;
% end
%% Calculate the mean background using statistics
for k=1:nTraces
    traceStart   = startOfTrace(k)-lenBackset(k);
    traceEnd     = endOfTrace(k)+lenBaseline(k);
    bgndStart    = endOfTrace(k)+1;
    
    effTraceBgd  = intensity(k,bgndStart:traceEnd);
    % Find most frequent values in array
    modeBgd      = mode(effTraceBgd);
    % n can be changed: use Gui correctTraceBgd.m to investigate behaviour
    n            = 0.5;
    stdvBgd      = n*std(intensity(k,bgndStart:traceEnd));
    upLimit      = modeBgd + stdvBgd;
    % only use the part of the bgd intensity below the upper Limit to
    % calculate the mean bgd
    idx          = effTraceBgd  < upLimit;
    meanBgd      = mean(effTraceBgd(idx));
    
    
    if ~isnan(meanBgd)
        corrBgd(k,traceStart:traceEnd) = meanBgd;
    else
        corrBgd(k,traceStart:traceEnd) = 0;
    end
end


%% Calculate total mean of background and subsitute zero entries in the 
% corrBgd matrix with the total mean
% if any(corrBgd)
%     totalMean = mean(corrBgd(corrBgd>0),1); % totalMean is a scalar not a vector
% else 
%     totalMean = 0;
% end
% 
% for l=1:nTraces
%     if sum(corrBgd(l,:))==0 % locate rows in the corrBgd matrix with zero's
%         corrBgd(l,traceStart:traceEnd)=totalMean;
%     end
% end

%% Subtract background from every trace
for m=1:nTraces
    %bgndMean=corrBgd(m,find(corrBgd(m,:)>0,1,'first'));
    traceStart  = startOfTrace(m)-lenBackset(m);
    traceEnd    = endOfTrace(m)+lenBaseline(m);
    bgndMean    = corrBgd(m,traceStart);
    if sum(bgndMean,2)>0
        % Subtract a mean background value 
        
        %corrInt(m,traceStart:traceEnd) = intensity(m,traceStart:traceEnd)...
        %                                           - bgndMean;
        
        % Check whether the result is below negLimit
        corrVal = intensity(m,traceStart:traceEnd)- bgndMean;
        negLimit = -250;
         if any(corrVal < negLimit)
            corrInt(m,traceStart:traceEnd) = intensity(m,traceStart:traceEnd);
         else
            corrInt(m,traceStart:traceEnd) = corrVal; 
         end
         
    elseif sum(bgndMean,2)==0
        %disp(['bgndMean is empty for trace' num2str(m)]);
        corrInt(m,traceStart:traceEnd) = intensity(m,traceStart:traceEnd);
    end
end

%% Save the modified *.phc traces file
if isfield(data,'xCorr')
    data.channelNames = {'x','y','xCorr','yCorr','int','snr','locInt','locBgd'};
else
    data.channelNames = {'x','y','int','snr','locInt','locBgd'};
end

data.int = corrInt;
data.locInt = intensity;

for i=1:nTraces
    data.traceMetadata(i).lenBackset   = lenBackset(i);
    data.traceMetadata(i).startOfTrace = startOfTrace(i); % unit frames
    data.traceMetadata(i).endOfTrace   = endOfTrace(i);
    data.traceMetadata(i).lenBaseline  = lenBaseline(i);
    data.traceMetadata(i).traceLen     = endOfTrace(i) - startOfTrace(i)+1;
end
saveTracesCell(outfile1,'traces',data);

% Save the modified *.bgd traces file 
if ~isempty(outfile2)
    data.int = corrBgd;
    for i=1:nTraces
        data.traceMetadata(i).lenBaseline = lenBaseline(i);
    end
    saveTracesCell(outfile2,'traces',data);
end
%%


